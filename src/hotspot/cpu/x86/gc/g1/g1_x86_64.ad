//
// Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License version 2 only, as
// published by the Free Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// You should have received a copy of the GNU General Public License version
// 2 along with this work; if not, write to the Free Software Foundation,
// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
//
// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
// or visit www.oracle.com if you need additional information or have any
// questions.
//

source_hpp %{

#include "gc/g1/c2/g1BarrierSetC2.hpp"

%}

source %{

#include "gc/g1/g1BarrierSetAssembler_x86.hpp"
#include "gc/g1/g1BarrierSetRuntime.hpp"

static void g1_pre_write_barrier(MacroAssembler& _masm,
                                 const MachNode* node,
                                 Register obj,
                                 Register pre_val,
                                 Register tmp,
                                 uint8_t barrier_data,
                                 RegSet preserve = RegSet(),
                                 RegSet no_preserve = RegSet()) {
  if (!G1PreBarrierStubC2::needs_barrier(node)) {
    return;
  }
  Assembler::InlineSkippedInstructionsCounter skip_counter(&_masm);
  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());
  G1PreBarrierStubC2* const stub = G1PreBarrierStubC2::create(node);
  for (RegSetIterator<Register> reg = preserve.begin(); *reg != noreg; ++reg) {
    stub->preserve(*reg);
  }
  for (RegSetIterator<Register> reg = no_preserve.begin(); *reg != noreg; ++reg) {
    stub->dont_preserve(*reg);
  }
  g1_asm->g1_write_barrier_pre_c2(&_masm /* masm */,
                                  obj /* obj */,
                                  pre_val /* pre_val */,
                                  r15_thread /* thread */,
                                  tmp /* tmp */,
                                  stub);
}

static void g1_post_write_barrier(MacroAssembler& _masm,
                                  const MachNode* node,
                                  Register store_addr,
                                  Register new_val,
                                  Register tmp1,
                                  Register tmp2,
                                  uint8_t barrier_data) {
  if (!G1PostBarrierStubC2::needs_barrier(node)) {
    return;
  }
  Assembler::InlineSkippedInstructionsCounter skip_counter(&_masm);
  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());
  G1PostBarrierStubC2* const stub = G1PostBarrierStubC2::create(node);
  g1_asm->g1_write_barrier_post_c2(&_masm /* masm */,
                                   store_addr /* store_addr */,
                                   new_val /* new_val */,
                                   r15_thread /* thread */,
                                   tmp1 /* tmp */,
                                   tmp2 /* tmp2 */,
                                   stub);
}

%}

// Store Pointer
instruct g1StoreP(memory mem, any_RegP src, rRegP tmp1, rRegP tmp2, rRegP tmp3, rFlagsReg cr)
%{
  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);
  match(Set mem (StoreP mem src));
  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(125); // XXX
  format %{ "movq    $mem, $src\t# ptr" %}
  ins_encode %{
    if (G1ProfileBarriers) {
      __ incrementq(Address(r15_thread, JavaThread::store_counter_offset()));
      if ((barrier_data() & G1C2BarrierPost) == 0) {
        __ incrementq(Address(r15_thread, JavaThread::store_nopost_counter_offset()));
      }
      if ((barrier_data() & G1C2BarrierPostNotNull) != 0) {
        __ incrementq(Address(r15_thread, JavaThread::store_notnull_counter_offset()));
      }
    }
    __ lea($tmp1$$Register, $mem$$Address);
    RegSet preserve_set = RegSet::of($tmp1$$Register, $src$$Register);
    G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());
    Register base = g1_asm->imprecise_marking_address_via_address(this, $mem$$Address);
    Register base2 = g1_asm->imprecise_marking_address_via_type(this);
    assert(base == base2, "should be equivalent");
    if (base != noreg) {
      preserve_set += RegSet::of(base);
    }
    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $tmp1$$Register /* obj */,
                         $tmp2$$Register /* pre_val */,
                         $tmp3$$Register /* tmp */,
                         barrier_data() /* barrier_data */,
                         preserve_set /* preserve */);
    __ movq(Address($tmp1$$Register, 0), $src$$Register);
    Register store_addr = base != noreg ? base : $tmp1$$Register;
    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          store_addr /* store_addr */,
                          $src$$Register /* new_val */,
                          $tmp3$$Register /* tmp1 */,
                          $tmp2$$Register /* tmp2 */,
                          barrier_data() /* barrier_data */);
  %}
  ins_pipe(ialu_mem_reg);
%}

instruct g1StoreN(memory mem, rRegN src, rRegP tmp1, rRegP tmp2, rRegP tmp3, rFlagsReg cr)
%{
  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);
  match(Set mem (StoreN mem src));
  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(125); // XXX
  format %{ "movl    $mem, $src\t# ptr" %}
  ins_encode %{
    if (G1ProfileBarriers) {
      __ incrementq(Address(r15_thread, JavaThread::store_counter_offset()));
      if ((barrier_data() & G1C2BarrierPost) == 0) {
        __ incrementq(Address(r15_thread, JavaThread::store_nopost_counter_offset()));
      }
      if ((barrier_data() & G1C2BarrierPostNotNull) != 0) {
        __ incrementq(Address(r15_thread, JavaThread::store_notnull_counter_offset()));
      }
    }
    assert(!in(operand_index(2))->is_Mach() ||
           (in(operand_index(2))->as_Mach()->ideal_Opcode() != Op_EncodeP),
           "EncodeP src nodes should be matched with their corresponding StoreN nodes");
    __ lea($tmp1$$Register, $mem$$Address);
    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $tmp1$$Register /* obj */,
                         $tmp2$$Register /* pre_val */,
                         $tmp3$$Register /* tmp */,
                         barrier_data() /* barrier_data */,
                         RegSet::of($tmp1$$Register, $src$$Register) /* preserve */);
    __ movl(Address($tmp1$$Register, 0), $src$$Register);
    if ((barrier_data() & G1C2BarrierPost) != 0) {
      __ movl($tmp2$$Register, $src$$Register);
      if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {
        __ decode_heap_oop($tmp2$$Register);
      } else {
        __ decode_heap_oop_not_null($tmp2$$Register);
      }
    }
    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $tmp1$$Register /* store_addr */,
                          $tmp2$$Register /* new_val */,
                          $tmp3$$Register /* tmp1 */,
                          $tmp2$$Register /* tmp2 */,
                          barrier_data() /* barrier_data */);
  %}
  ins_pipe(ialu_mem_reg);
%}

instruct g1EncodePAndStoreN(memory mem, any_RegP src, rRegP tmp1, rRegP tmp2, rRegP tmp3, rFlagsReg cr)
%{
  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);
  match(Set mem (StoreN mem (EncodeP src)));
  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(125); // XXX
  format %{ "encode_heap_oop $src\n\t"
            "movl   $mem, $src\t# ptr" %}
  ins_encode %{
    if (G1ProfileBarriers) {
      __ incrementq(Address(r15_thread, JavaThread::store_encode_counter_offset()));
      if ((barrier_data() & G1C2BarrierPost) == 0) {
        __ incrementq(Address(r15_thread, JavaThread::store_nopost_counter_offset()));
      }
      if ((barrier_data() & G1C2BarrierPostNotNull) != 0) {
        __ incrementq(Address(r15_thread, JavaThread::store_notnull_counter_offset()));
      }
    }
    __ lea($tmp1$$Register, $mem$$Address);
    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $tmp1$$Register /* obj */,
                         $tmp2$$Register /* pre_val */,
                         $tmp3$$Register /* tmp */,
                         barrier_data() /* barrier_data */,
                         RegSet::of($tmp1$$Register, $src$$Register) /* preserve */);
    __ movq($tmp2$$Register, $src$$Register);
    if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {
      __ encode_heap_oop($tmp2$$Register);
    } else {
      __ encode_heap_oop_not_null($tmp2$$Register);
    }
    __ movl(Address($tmp1$$Register, 0), $tmp2$$Register);
    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $tmp1$$Register /* store_addr */,
                          $src$$Register /* new_val */,
                          $tmp3$$Register /* tmp1 */,
                          $tmp2$$Register /* tmp2 */,
                          barrier_data() /* barrier_data */);
  %}
  ins_pipe(ialu_mem_reg);
%}

instruct g1CompareAndExchangeP(indirect mem, rRegP newval, rRegP tmp1, rRegP tmp2, rRegP tmp3, rax_RegP oldval, rFlagsReg cr)
%{
  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);
  match(Set oldval (CompareAndExchangeP mem (Binary oldval newval)));
  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  format %{ "lock\n\t"
            "cmpxchgq $newval, $mem" %}

  ins_encode %{
    if (G1ProfileBarriers) {
      __ incrementq(Address(r15_thread, JavaThread::atomic_counter_offset()));
    }
    assert_different_registers($oldval$$Register, $mem$$Register);
    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register /* obj */,
                         $tmp2$$Register /* pre_val */,
                         $tmp3$$Register /* tmp */,
                         barrier_data() /* barrier_data */,
                         RegSet::of($mem$$Register, $newval$$Register, $oldval$$Register) /* preserve */);
    __ movq($tmp1$$Register, $newval$$Register);
    __ lock();
    __ cmpxchgq($tmp1$$Register, Address($mem$$Register, 0));
    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $tmp1$$Register /* new_val */,
                          $tmp2$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_cmpxchg);
%}

instruct g1CompareAndExchangeN(indirect mem, rRegN newval, rRegP tmp1, rRegP tmp2, rRegP tmp3, rax_RegN oldval, rFlagsReg cr)
%{
  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);
  match(Set oldval (CompareAndExchangeN mem (Binary oldval newval)));
  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  format %{ "lock\n\t"
            "cmpxchgq $newval, $mem" %}

  ins_encode %{
    if (G1ProfileBarriers) {
      __ incrementq(Address(r15_thread, JavaThread::atomic_counter_offset()));
    }
    assert_different_registers($oldval$$Register, $mem$$Register);
    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register /* obj */,
                         $tmp2$$Register /* pre_val */,
                         $tmp3$$Register /* tmp */,
                         barrier_data() /* barrier_data */,
                         RegSet::of($mem$$Register, $newval$$Register, $oldval$$Register) /* preserve */);
    __ movl($tmp1$$Register, $newval$$Register);
    __ lock();
    __ cmpxchgl($tmp1$$Register, Address($mem$$Register, 0));
    __ decode_heap_oop($tmp1$$Register);
    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $tmp1$$Register /* new_val */,
                          $tmp2$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_cmpxchg);
%}

instruct g1CompareAndSwapP(rRegI res, indirect mem, rRegP newval, rRegP tmp1, rRegP tmp2, rRegP tmp3, rax_RegP oldval, rFlagsReg cr)
%{
  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);
  match(Set res (CompareAndSwapP mem (Binary oldval newval)));
  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL oldval, KILL cr);

  format %{ "lock\n\t"
            "cmpxchgq $newval, $mem\n\t"
            "sete     $res\n\t"
            "movzbl   $res, $res" %}

  ins_encode %{
    if (G1ProfileBarriers) {
      __ incrementq(Address(r15_thread, JavaThread::atomic_counter_offset()));
    }
    assert_different_registers($oldval$$Register, $mem$$Register);
    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register /* obj */,
                         $tmp2$$Register /* pre_val */,
                         $tmp3$$Register /* tmp */,
                         barrier_data() /* barrier_data */,
                         RegSet::of($mem$$Register, $newval$$Register, $oldval$$Register) /* preserve */,
                         RegSet::of($res$$Register) /* no_preserve */);
    __ movq($tmp1$$Register, $newval$$Register);
    __ lock();
    __ cmpxchgq($tmp1$$Register, Address($mem$$Register, 0));
    __ setb(Assembler::equal, $res$$Register);
    __ movzbl($res$$Register, $res$$Register);
    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $tmp1$$Register /* new_val */,
                          $tmp2$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_cmpxchg);
%}

instruct g1CompareAndSwapN(rRegI res, indirect mem, rRegN newval, rRegP tmp1, rRegP tmp2, rRegP tmp3, rax_RegN oldval, rFlagsReg cr)
%{
  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);
  match(Set res (CompareAndSwapN mem (Binary oldval newval)));
  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));
  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL oldval, KILL cr);

  format %{ "lock\n\t"
            "cmpxchgq $newval, $mem\n\t"
            "sete     $res\n\t"
            "movzbl   $res, $res" %}

  ins_encode %{
    if (G1ProfileBarriers) {
      __ incrementq(Address(r15_thread, JavaThread::atomic_counter_offset()));
    }
    assert_different_registers($oldval$$Register, $mem$$Register);
    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register /* obj */,
                         $tmp2$$Register /* pre_val */,
                         $tmp3$$Register /* tmp */,
                         barrier_data() /* barrier_data */,
                         RegSet::of($mem$$Register, $newval$$Register, $oldval$$Register) /* preserve */,
                         RegSet::of($res$$Register) /* no_preserve */);
    __ movl($tmp1$$Register, $newval$$Register);
    __ lock();
    __ cmpxchgl($tmp1$$Register, Address($mem$$Register, 0));
    __ setb(Assembler::equal, $res$$Register);
    __ movzbl($res$$Register, $res$$Register);
    __ decode_heap_oop($tmp1$$Register);
    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $tmp1$$Register /* new_val */,
                          $tmp2$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_cmpxchg);
%}

instruct g1XChgP(indirect mem, rRegP newval, rRegP tmp1, rRegP tmp2, rRegP tmp3, rFlagsReg cr)
%{
  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);
  match(Set newval (GetAndSetP mem newval));
  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  format %{ "xchgq    $newval, $mem" %}

  ins_encode %{
    if (G1ProfileBarriers) {
      __ incrementq(Address(r15_thread, JavaThread::atomic_counter_offset()));
    }
    assert_different_registers($mem$$Register, $newval$$Register);
    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register /* obj */,
                         $tmp2$$Register /* pre_val */,
                         $tmp3$$Register /* tmp */,
                         barrier_data() /* barrier_data */,
                         RegSet::of($mem$$Register, $newval$$Register) /* preserve */);
    __ movq($tmp1$$Register, $newval$$Register);
    __ xchgq($newval$$Register, Address($mem$$Register, 0));
    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $tmp1$$Register /* new_val */,
                          $tmp2$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_cmpxchg);
%}

instruct g1XChgN(indirect mem, rRegN newval, rRegP tmp1, rRegP tmp2, rRegP tmp3, rFlagsReg cr)
%{
  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);
  match(Set newval (GetAndSetN mem newval));
  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  format %{ "xchgq    $newval, $mem" %}

  ins_encode %{
    if (G1ProfileBarriers) {
      __ incrementq(Address(r15_thread, JavaThread::atomic_counter_offset()));
    }
    assert_different_registers($mem$$Register, $newval$$Register);
    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register /* obj */,
                         $tmp2$$Register /* pre_val */,
                         $tmp3$$Register /* tmp */,
                         barrier_data() /* barrier_data */,
                         RegSet::of($mem$$Register, $newval$$Register) /* preserve */);
    __ movl($tmp1$$Register, $newval$$Register);
    __ decode_heap_oop($tmp1$$Register);
    __ xchgl($newval$$Register, Address($mem$$Register, 0));
    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $tmp1$$Register /* new_val */,
                          $tmp2$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_cmpxchg);
%}

// Load Pointer
instruct g1LoadP(rRegP dst, memory mem, rRegP tmp, rFlagsReg cr)
%{
  predicate(UseG1GC && n->as_Load()->barrier_data() != 0);
  match(Set dst (LoadP mem));
  effect(TEMP dst, TEMP tmp, KILL cr);

  ins_cost(125); // XXX
  format %{ "movq    $dst, $mem\t# ptr" %}
  ins_encode %{
    if (G1ProfileBarriers) {
      __ incrementq(Address(r15_thread, JavaThread::load_counter_offset()));
    }
    __ movq($dst$$Register, $mem$$Address);
    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         noreg /* obj */,
                         $dst$$Register /* pre_val */,
                         $tmp$$Register /* tmp */,
                         barrier_data() /* barrier_data */);
  %}
  ins_pipe(ialu_reg_mem); // XXX
%}

// Load Compressed Pointer
instruct g1LoadN(rRegN dst, memory mem, rRegP tmp1, rRegP tmp2, rFlagsReg cr)
%{
  predicate(UseG1GC && n->as_Load()->barrier_data() != 0);
  match(Set dst (LoadN mem));
  effect(TEMP dst, TEMP tmp1, TEMP tmp2, KILL cr);

  ins_cost(125); // XXX
  format %{ "movl    $dst, $mem\t# compressed ptr" %}
  ins_encode %{
    if (G1ProfileBarriers) {
      __ incrementq(Address(r15_thread, JavaThread::load_counter_offset()));
    }
    __ movl($dst$$Register, $mem$$Address);
    __ movl($tmp1$$Register, $dst$$Register);
    __ decode_heap_oop($tmp1$$Register);
    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         noreg /* obj */,
                         $tmp1$$Register /* pre_val */,
                         $tmp2$$Register /* tmp */,
                         barrier_data() /* barrier_data */);
  %}
  ins_pipe(ialu_reg_mem); // XXX
%}