//
// Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License version 2 only, as
// published by the Free Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// You should have received a copy of the GNU General Public License version
// 2 along with this work; if not, write to the Free Software Foundation,
// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
//
// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
// or visit www.oracle.com if you need additional information or have any
// questions.
//

source_hpp %{

#include "gc/g1/c2/g1BarrierSetC2.hpp"

%}

source %{

#include "gc/g1/g1BarrierSetAssembler_aarch64.hpp"
#include "gc/g1/g1BarrierSetRuntime.hpp"

static void g1_pre_write_barrier(MacroAssembler& _masm,
                                 const MachNode* node, 
                                 Register obj,
                                 Register pre_val,
                                 Register tmp1,
                                 Register tmp2,
                                 Register node_tmp1,
                                 Register node_tmp2,
                                 Register node_tmp3,
                                 uint8_t barrier_data) {
  if (barrier_data == G1C2BarrierElided) {
    return;
  }
  if ((barrier_data & G1C2BarrierPre) == 0) {
    return;
  }
  Assembler::InlineSkippedInstructionsCounter skip_counter(&_masm);
  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());
  G1BarrierStubC2* const stub = G1BarrierStubC2::create(node, pre_val, node_tmp1, node_tmp2, node_tmp3, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry));
  g1_asm->g1_write_barrier_pre(&_masm /* masm */,
                               obj /* obj */,
                               pre_val /* pre_val */,
                               rthread /* thread */,
                               tmp1 /* tmp1 */,
                               tmp2 /* tmp2 */,
                               false /* tosca_live */,
                               true /* expand_call */,
                               stub);
  __ bind(*stub->continuation());
}

static void g1_post_write_barrier(MacroAssembler& _masm,
                                  const MachNode* node, 
                                  Register store_addr,
                                  Register new_val,
                                  Register tmp1,
                                  Register tmp2,
                                  Register node_tmp1,
                                  Register node_tmp2,
                                  Register node_tmp3,
                                  uint8_t barrier_data) {
  if (barrier_data == G1C2BarrierElided) {
    return;
  }
  if ((barrier_data & G1C2BarrierPost) == 0) {
    return;
  }
  Assembler::InlineSkippedInstructionsCounter skip_counter(&_masm);
  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());
  G1BarrierStubC2* const stub = G1BarrierStubC2::create(node, tmp1, node_tmp1, node_tmp2, node_tmp3, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry));
  g1_asm->g1_write_barrier_post(&_masm /* masm */,
                                store_addr /* store_addr */,
                                new_val /* new_val */,
                                rthread /* thread */,
                                tmp1 /* tmp1 */,
                                tmp2 /* tmp2 */,
                                stub);
  __ bind(*stub->continuation());
}

%}

// Store Pointer
instruct g1StoreP(indirect mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)
%{
  predicate(UseG1GC && !needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);
  match(Set mem (StoreP mem src));
  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(125); // XXX
  format %{ "movq    $mem, $src\t# ptr" %}
  ins_encode %{
    DecoratorSet decorators = IN_HEAP;
    const Address ref_addr = Address($mem$$Register, 0);

    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register /* obj */,
                         $tmp1$$Register /* pre_val */,
                         $tmp2$$Register /* tmp1 */,
                         $tmp3$$Register /* tmp2 */,
                         $tmp1$$Register /* node_tmp1 */,
                         $tmp2$$Register /* node_tmp2 */,
                         $tmp3$$Register /* node_tmp3 */,
                         barrier_data() /* barrier_data */);

    __ str($src$$Register, ref_addr);

    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $src$$Register /* new_val */,
                          $tmp2$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          $tmp1$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          $tmp3$$Register /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
  %}
  ins_pipe(pipe_serial);
%}

// Store Pointer Volatile
instruct g1StorePVolatile(indirect mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)
%{
  predicate(UseG1GC && needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);
  match(Set mem (StoreP mem src));
  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(125); // XXX
  format %{ "movq    $mem, $src\t# ptr" %}
  ins_encode %{
    DecoratorSet decorators = IN_HEAP;

    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register/* obj */,
                         $tmp1$$Register /* pre_val */,
                         $tmp2$$Register /* tmp1 */,
                         $tmp3$$Register /* tmp2 */,
                         $tmp1$$Register /* node_tmp1 */,
                         $tmp2$$Register /* node_tmp2 */,
                         $tmp3$$Register /* node_tmp3 */,
                         barrier_data() /* barrier_data */);

    __ stlr($src$$Register, $mem$$Register);

    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $src$$Register /* new_val */,
                          $tmp2$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          $tmp1$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          $tmp3$$Register /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
  %}
  ins_pipe(pipe_serial);
%}

instruct g1StoreN(indirect mem, iRegN src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)
%{
  predicate(UseG1GC && !needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);
  match(Set mem (StoreN mem src));
  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(125); // XXX
  format %{ "strw  $src, $mem\t# compressed ptr" %}
  ins_encode %{
    DecoratorSet decorators = IN_HEAP;
    const Address ref_addr = Address($mem$$Register, 0);

    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register /* obj */,
                         $tmp1$$Register /* pre_val */,
                         $tmp2$$Register /* tmp1 */,
                         $tmp3$$Register /* tmp2 */,
                         $tmp1$$Register /* node_tmp1 */,
                         $tmp2$$Register /* node_tmp2 */,
                         $tmp3$$Register /* node_tmp3 */,
                         barrier_data() /* barrier_data */);

    __ strw($src$$Register, ref_addr);
    __ mov($tmp1$$Register, $src$$Register);
    __ decode_heap_oop($tmp1$$Register);

    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $tmp1$$Register /* new_val */,
                          $tmp2$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          $tmp1$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          $tmp3$$Register /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
  %}
  ins_pipe(pipe_serial);
%}

instruct g1StoreNVolatile(indirect mem, iRegN src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)
%{
  predicate(UseG1GC && needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);
  match(Set mem (StoreN mem src));
  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(125); // XXX
  format %{ "stlrw  $src, $mem\t# compressed ptr" %}
  ins_encode %{
    DecoratorSet decorators = IN_HEAP;
    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register/* obj */,
                         $tmp1$$Register /* pre_val */,
                         $tmp2$$Register /* tmp1 */,
                         $tmp3$$Register /* tmp2 */,
                         $tmp1$$Register /* node_tmp1 */,
                         $tmp2$$Register /* node_tmp2 */,
                         $tmp3$$Register /* node_tmp3 */,
                         barrier_data() /* barrier_data */);

    __ stlrw($src$$Register, $mem$$Register);
    __ movw($tmp1$$Register, $src$$Register);
    __ decode_heap_oop($tmp1$$Register);

    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $tmp1$$Register /* new_val */,
                          $tmp2$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          $tmp1$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          $tmp3$$Register /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
  %}
  ins_pipe(pipe_serial);
%}

instruct g1CompareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr) 
%{
  predicate(UseG1GC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);

  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "cmpxchg $mem, $oldval, $newval\n\t" %}

  ins_encode %{
    assert_different_registers($oldval$$Register, $mem$$Register);
    assert_different_registers($oldval$$Register, $newval$$Register);
    DecoratorSet decorators = IN_HEAP;

    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register/* obj */,
                         $tmp1$$Register /* pre_val */,
                         $tmp2$$Register /* tmp1 */,
                         $tmp3$$Register /* tmp2 */,
                         $tmp1$$Register /* node_tmp1 */,
                         $tmp2$$Register /* node_tmp2 */,
                         $tmp3$$Register /* node_tmp3 */,
                         barrier_data() /* barrier_data */);

    __ mov($tmp1$$Register, $oldval$$Register);
    __ mov($tmp2$$Register, $newval$$Register);

    __ cmpxchg($mem$$Register, $tmp1$$Register, $tmp2$$Register, Assembler::xword,
               false /* acquire */, true /* release */, false /* weak */, $res$$Register);

    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $tmp2$$Register /* new_val */,
                          $tmp1$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          $tmp1$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          $res$$Register /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_slow);
%}

instruct g1CompareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr) 
%{
  predicate(UseG1GC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);

  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "cmpxchg $mem, $oldval, $newval\n\t" %}

  ins_encode %{
    assert_different_registers($oldval$$Register, $mem$$Register);
    assert_different_registers($oldval$$Register, $newval$$Register);
    DecoratorSet decorators = IN_HEAP;

    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register/* obj */,
                         $tmp1$$Register /* pre_val */,
                         $tmp2$$Register /* tmp1 */,
                         $tmp3$$Register /* tmp2 */,
                         $tmp1$$Register /* node_tmp1 */,
                         $tmp2$$Register /* node_tmp2 */,
                         $tmp3$$Register /* node_tmp3 */,
                         barrier_data() /* barrier_data */);

    __ mov($tmp1$$Register, $oldval$$Register);
    __ mov($tmp2$$Register, $newval$$Register);

    __ cmpxchg($mem$$Register, $tmp1$$Register, $tmp2$$Register, Assembler::xword,
               true /* acquire */, true /* release */, false /* weak */, $res$$Register);

    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $tmp2$$Register /* new_val */,
                          $tmp1$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          $tmp1$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          $res$$Register /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_slow);
%}

instruct g1CompareAndExchangeN(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr) 
%{
  predicate(UseG1GC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);

  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));
  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "cmpxchg $mem, $oldval, $newval\n\t" %}

  ins_encode %{
    assert_different_registers($oldval$$Register, $mem$$Register);
    assert_different_registers($oldval$$Register, $newval$$Register);
    DecoratorSet decorators = IN_HEAP;

    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register/* obj */,
                         $tmp1$$Register /* pre_val */,
                         $tmp2$$Register /* tmp1 */,
                         $tmp3$$Register /* tmp2 */,
                         $tmp1$$Register /* node_tmp1 */,
                         $tmp2$$Register /* node_tmp2 */,
                         $tmp3$$Register /* node_tmp3 */,
                         barrier_data() /* barrier_data */);

    __ mov($tmp1$$Register, $oldval$$Register);
    __ mov($tmp2$$Register, $newval$$Register);

    __ cmpxchg($mem$$Register, $tmp1$$Register, $tmp2$$Register, Assembler::word,
               false /* acquire */, true /* release */, false /* weak */, $res$$Register);
    
    __ decode_heap_oop($tmp2$$Register);

    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $tmp2$$Register /* new_val */,
                          $tmp1$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          $tmp1$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          $res$$Register /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_slow);
%}

instruct g1CompareAndExchangeNAcq(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr) 
%{
  predicate(UseG1GC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);

  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));
  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "cmpxchg $mem, $oldval, $newval\n\t" %}

  ins_encode %{
    assert_different_registers($oldval$$Register, $mem$$Register);
    assert_different_registers($oldval$$Register, $newval$$Register);
    DecoratorSet decorators = IN_HEAP;

    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register/* obj */,
                         $tmp1$$Register /* pre_val */,
                         $tmp2$$Register /* tmp1 */,
                         $tmp3$$Register /* tmp2 */,
                         $tmp1$$Register /* node_tmp1 */,
                         $tmp2$$Register /* node_tmp2 */,
                         $tmp3$$Register /* node_tmp3 */,
                         barrier_data() /* barrier_data */);

    __ mov($tmp1$$Register, $oldval$$Register);
    __ mov($tmp2$$Register, $newval$$Register);

    __ cmpxchg($mem$$Register, $tmp1$$Register, $tmp2$$Register, Assembler::word,
               true /* acquire */, true /* release */, false /* weak */, $res$$Register);

    __ decode_heap_oop($tmp2$$Register);

    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $tmp2$$Register /* new_val */,
                          $tmp1$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          $tmp1$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          $res$$Register /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_slow);
%}

instruct g1CompareAndSwapP(iRegINoSp res, indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegP oldval, rFlagsReg cr) 
%{
  predicate(UseG1GC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);

  match(Set res (CompareAndSwapP mem (Binary oldval newval)));
  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "cmpxchg $mem, $oldval, $newval\n\t"
            "cset    $res, EQ" %}

  ins_encode %{
    assert_different_registers($oldval$$Register, $mem$$Register);
    assert_different_registers($oldval$$Register, $newval$$Register);
    DecoratorSet decorators = IN_HEAP;

    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register/* obj */,
                         $tmp1$$Register /* pre_val */,
                         $tmp2$$Register /* tmp1 */,
                         $tmp3$$Register /* tmp2 */,
                         $res$$Register /* node_tmp1 */,
                         $tmp2$$Register /* node_tmp2 */,
                         $tmp3$$Register /* node_tmp3 */,
                         barrier_data() /* barrier_data */);

    __ mov($tmp1$$Register, $oldval$$Register);
    __ mov($tmp2$$Register, $newval$$Register);

    __ cmpxchg($mem$$Register, $tmp1$$Register, $tmp2$$Register, Assembler::xword,
               false /* acquire */, true /* release */, false /* weak */, noreg);
    __ cset($res$$Register, Assembler::EQ);

    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $tmp2$$Register /* new_val */,
                          $tmp1$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          $res$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          $tmp3$$Register /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_slow);
%}

instruct g1CompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegP oldval, rFlagsReg cr) 
%{
  predicate(UseG1GC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);

  match(Set res (CompareAndSwapP mem (Binary oldval newval)));
  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "cmpxchg $mem, $oldval, $newval\n\t"
            "cset    $res, EQ" %}

  ins_encode %{
    assert_different_registers($oldval$$Register, $mem$$Register);
    assert_different_registers($oldval$$Register, $newval$$Register);
    DecoratorSet decorators = IN_HEAP;

    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register/* obj */,
                         $tmp1$$Register /* pre_val */,
                         $tmp2$$Register /* tmp1 */,
                         $tmp3$$Register /* tmp2 */,
                         $res$$Register /* node_tmp1 */,
                         $tmp2$$Register /* node_tmp2 */,
                         $tmp3$$Register /* node_tmp3 */,
                         barrier_data() /* barrier_data */);
                         
    __ mov($tmp1$$Register, $oldval$$Register);
    __ mov($tmp2$$Register, $newval$$Register);

    __ cmpxchg($mem$$Register, $tmp1$$Register, $tmp2$$Register, Assembler::xword,
               true /* acquire */, true /* release */, false /* weak */, noreg);
    __ cset($res$$Register, Assembler::EQ);

    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $tmp2$$Register /* new_val */,
                          $tmp1$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          $res$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          $tmp3$$Register /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_slow);
%}

instruct g1CompareAndSwapN(iRegINoSp res, indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegN oldval, rFlagsReg cr) 
%{
  predicate(UseG1GC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);

  match(Set res (CompareAndSwapN mem (Binary oldval newval)));
  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));
  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "cmpxchg $mem, $oldval, $newval\n\t"
            "cset    $res, EQ" %}

  ins_encode %{
    assert_different_registers($oldval$$Register, $mem$$Register);
    assert_different_registers($oldval$$Register, $newval$$Register);
    DecoratorSet decorators = IN_HEAP;

    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register/* obj */,
                         $tmp1$$Register /* pre_val */,
                         $tmp2$$Register /* tmp1 */,
                         $tmp3$$Register /* tmp2 */,
                         $res$$Register /* node_tmp1 */,
                         $tmp2$$Register /* node_tmp2 */,
                         $tmp3$$Register /* node_tmp3 */,
                         barrier_data() /* barrier_data */);

    __ mov($tmp1$$Register, $oldval$$Register);
    __ mov($tmp2$$Register, $newval$$Register);

    __ cmpxchg($mem$$Register, $tmp1$$Register, $tmp2$$Register, Assembler::word,
               false /* acquire */, true /* release */, false /* weak */, noreg);
    __ cset($res$$Register, Assembler::EQ);
    __ decode_heap_oop($tmp2$$Register);

    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $tmp2$$Register /* new_val */,
                          $tmp1$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          $res$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          $tmp3$$Register /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_slow);
%}

instruct g1CompareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegN oldval, rFlagsReg cr) 
%{
  predicate(UseG1GC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);

  match(Set res (CompareAndSwapN mem (Binary oldval newval)));
  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));
  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "cmpxchg $mem, $oldval, $newval\n\t"
            "cset    $res, EQ" %}

  ins_encode %{
    assert_different_registers($oldval$$Register, $mem$$Register);
    assert_different_registers($oldval$$Register, $newval$$Register);
    DecoratorSet decorators = IN_HEAP;

    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         $mem$$Register/* obj */,
                         $tmp1$$Register /* pre_val */,
                         $tmp2$$Register /* tmp1 */,
                         $tmp3$$Register /* tmp2 */,
                         $res$$Register /* node_tmp1 */,
                         $tmp2$$Register /* node_tmp2 */,
                         $tmp3$$Register /* node_tmp3 */,
                         barrier_data() /* barrier_data */);
    __ mov($tmp1$$Register, $oldval$$Register);
    __ mov($tmp2$$Register, $newval$$Register);

    __ cmpxchg($mem$$Register, $tmp1$$Register, $tmp2$$Register, Assembler::word,
               true /* acquire */, true /* release */, false /* weak */, noreg);
    __ cset($res$$Register, Assembler::EQ);
    __ decode_heap_oop($tmp2$$Register);

    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $tmp2$$Register /* new_val */,
                          $tmp1$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          $res$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          $tmp3$$Register /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_slow);
%}

instruct g1XChgP(indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp preval, rFlagsReg cr) 
%{
  predicate(UseG1GC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);

  match(Set preval (GetAndSetP mem newval));
  effect(TEMP preval, TEMP tmp1, TEMP tmp2, KILL cr);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "xchgq    $newval, $mem" %}

  ins_encode %{
    assert_different_registers($mem$$Register, $newval$$Register);
    DecoratorSet decorators = IN_HEAP;

    __ atomic_xchg($preval$$Register, $newval$$Register, $mem$$Register);

    g1_pre_write_barrier(_masm /* _masm */,
                        this /* node */,
                        noreg /* obj */,
                        $preval$$Register /* pre_val */,
                        $tmp1$$Register /* tmp1 */,
                        $tmp2$$Register /* tmp2 */,
                        $preval$$Register /* node_tmp1 */,
                        $tmp1$$Register /* node_tmp2 */,
                        $tmp2$$Register /* node_tmp3 */,
                        barrier_data() /* barrier_data */);

    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $newval$$Register /* new_val */,
                          $tmp1$$Register /* tmp1 */,
                          $tmp2$$Register /* tmp2 */,
                          $tmp1$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          noreg /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_serial);
%}

instruct g1XChgPAcq(indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp preval, rFlagsReg cr) 
%{
  predicate(UseG1GC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);

  match(Set preval (GetAndSetP mem newval));
  effect(TEMP preval, TEMP tmp1, TEMP tmp2, KILL cr);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "xchgq    $newval, $mem" %}

  ins_encode %{
    assert_different_registers($mem$$Register, $newval$$Register);
    DecoratorSet decorators = IN_HEAP;

    __ atomic_xchgal($preval$$Register, $newval$$Register, $mem$$Register);

    g1_pre_write_barrier(_masm /* _masm */,
                        this /* node */,
                        noreg /* obj */,
                        $preval$$Register /* pre_val */,
                        $tmp1$$Register /* tmp1 */,
                        $tmp2$$Register /* tmp2 */,
                        $preval$$Register /* node_tmp1 */,
                        $tmp1$$Register /* node_tmp2 */,
                        $tmp2$$Register /* node_tmp3 */,
                        barrier_data() /* barrier_data */);

    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $newval$$Register /* new_val */,
                          $tmp1$$Register /* tmp1 */,
                          $tmp2$$Register /* tmp2 */,
                          $tmp1$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          noreg /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_serial);
%}

instruct g1XChgN(indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegNNoSp preval, rFlagsReg cr) 
%{
  predicate(UseG1GC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);

  match(Set preval (GetAndSetN mem newval));
  effect(TEMP preval, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "xchgq    $newval, $mem" %}

  ins_encode %{
    assert_different_registers($mem$$Register, $newval$$Register);
    DecoratorSet decorators = IN_HEAP;

    __ atomic_xchgw($preval$$Register, $newval$$Register, $mem$$Register);

    __ decode_heap_oop($newval$$Register);
    __ mov($tmp1$$Register, $preval$$Register);
    __ decode_heap_oop($tmp1$$Register);

    g1_pre_write_barrier(_masm /* _masm */,
                        this /* node */,
                        noreg /* obj */,
                        $tmp1$$Register /* pre_val */,
                        $tmp2$$Register /* tmp1 */,
                        $tmp3$$Register /* tmp2 */,
                        $preval$$Register /* node_tmp1 */,
                        $tmp1$$Register /* node_tmp2 */,
                        $tmp2$$Register /* node_tmp3 */,
                        barrier_data() /* barrier_data */);

    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $newval$$Register /* new_val */,
                          $tmp1$$Register /* tmp1 */,
                          $tmp2$$Register /* tmp2 */,
                          $tmp1$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          noreg /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_serial);
%}

instruct g1XChgNAcq(indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegNNoSp preval, rFlagsReg cr) 
%{
  predicate(UseG1GC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);

  match(Set preval (GetAndSetN mem newval));
  effect(TEMP preval, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "xchgq    $newval, $mem" %}

  ins_encode %{
    assert_different_registers($mem$$Register, $newval$$Register);
    DecoratorSet decorators = IN_HEAP;

    __ atomic_xchgalw($preval$$Register, $newval$$Register, $mem$$Register);

    __ decode_heap_oop($newval$$Register);
    __ mov($tmp1$$Register, $preval$$Register);
    __ decode_heap_oop($tmp1$$Register);

    g1_pre_write_barrier(_masm /* _masm */,
                        this /* node */,
                        noreg /* obj */,
                        $tmp1$$Register /* pre_val */,
                        $tmp2$$Register /* tmp1 */,
                        $tmp3$$Register /* tmp2 */,
                        $preval$$Register /* node_tmp1 */,
                        $tmp1$$Register /* node_tmp2 */,
                        $tmp2$$Register /* node_tmp3 */,
                        barrier_data() /* barrier_data */);

    g1_post_write_barrier(_masm /* _masm */,
                          this /* node */,
                          $mem$$Register /* store_addr */,
                          $newval$$Register /* new_val */,
                          $tmp1$$Register /* tmp1 */,
                          $tmp2$$Register /* tmp2 */,
                          $tmp1$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          noreg /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
  %}

  ins_pipe(pipe_serial);
%}

// Load Pointer
instruct g1LoadP(iRegPNoSp dst, memory mem, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)
%{
  predicate(UseG1GC && !needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);

  match(Set dst (LoadP mem));
  effect(TEMP dst, TEMP tmp1, TEMP tmp2, KILL cr);

  ins_cost(4 * INSN_COST);
  format %{ "movq    $dst, $mem\t# ptr" %}
  ins_encode %{
    const Address ref_addr = mem2address($mem->opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    __ ldr($dst$$Register, ref_addr);
    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         noreg /* obj */,
                         $dst$$Register /* pre_val */,
                         $tmp1$$Register /* tmp1 */,
                         $tmp2$$Register /* tmp2 */,
                         $dst$$Register /* node_tmp1 */,
                         $tmp1$$Register /* node_tmp2 */,
                         noreg /* node_tmp3 */,
                         barrier_data() /* barrier_data */);
  %}
  ins_pipe(iload_reg_mem); // XXX
%}

// Load Pointer Volatile
instruct g1LoadPVolatile(iRegPNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)
%{
  predicate(UseG1GC && needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);

  match(Set dst (LoadP mem));
  effect(TEMP dst, TEMP tmp1, TEMP tmp2, KILL cr);

  ins_cost(VOLATILE_REF_COST);
  format %{ "movq    $dst, $mem\t# ptr" %}
  ins_encode %{
    const Address ref_addr = Address($mem$$Register);
    __ ldar($dst$$Register, $mem$$Register);
    g1_pre_write_barrier(_masm /* _masm */,
                         this /* node */,
                         noreg /* obj */,
                         $dst$$Register /* pre_val */,
                         $tmp1$$Register /* tmp1 */,
                         $tmp2$$Register /* tmp2 */,
                         $dst$$Register /* node_tmp1 */,
                         $tmp1$$Register /* node_tmp2 */,
                         noreg /* node_tmp3 */,
                         barrier_data() /* barrier_data */);
  %}
  ins_pipe(iload_reg_mem); // XXX
%}

// Load Compressed Pointer
instruct g1LoadN(iRegNNoSp dst, memory mem, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)
%{
  predicate(UseG1GC && !needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);

  match(Set dst (LoadN mem));
  effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(4 * INSN_COST);
  format %{ "movq    $dst, $mem\t# ptr" %}
  ins_encode %{
    const Address ref_addr = mem2address($mem->opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    __ ldrw($dst$$Register, ref_addr);
    __ mov($tmp1$$Register, $dst$$Register);
    __ decode_heap_oop($tmp1$$Register);

    if ((barrier_data() & G1C2BarrierPre) != 0) {
      g1_pre_write_barrier(_masm /* _masm */,
                          this /* node */,
                          noreg /* obj */,
                          $tmp1$$Register /* pre_val */,
                          $tmp2$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          $tmp1$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          $dst$$Register /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
    }
  %}
  ins_pipe(iload_reg_mem); // XXX
%}

// Load Compressed Pointer Volatile
instruct g1LoadNVolatile(iRegNNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)
%{
  predicate(UseG1GC && needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);

  match(Set dst (LoadN mem));
  effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);

  ins_cost(VOLATILE_REF_COST);
  format %{ "movq    $dst, $mem\t# ptr" %}
  ins_encode %{
    const Address ref_addr = Address($mem$$Register);
    __ ldarw($dst$$Register, $mem$$Register);
    __ mov($tmp1$$Register, $dst$$Register);
    __ decode_heap_oop($tmp1$$Register);
    
    if ((barrier_data() & G1C2BarrierPre) != 0) {
      g1_pre_write_barrier(_masm /* _masm */,
                          this /* node */,
                          noreg /* obj */,
                          $tmp1$$Register /* pre_val */,
                          $tmp2$$Register /* tmp1 */,
                          $tmp3$$Register /* tmp2 */,
                          $tmp1$$Register /* node_tmp1 */,
                          $tmp2$$Register /* node_tmp2 */,
                          $dst$$Register /* node_tmp3 */,
                          barrier_data() /* barrier_data */);
    }
  %}
  ins_pipe(iload_reg_mem); // XXX
%}