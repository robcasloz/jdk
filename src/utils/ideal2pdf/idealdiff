#!/usr/bin/python3
#
# Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.

import argparse
import xml.etree.ElementTree as et
import networkx as nx

# Common helper functions.

def find(predicate, list):
    return next((e for e in list if predicate(e)), None)

# Helper functions for traversing the XML graph.

def find_node(graph, idx):
    for node in graph.find('nodes'):
        if int(node.attrib['id']) == idx:
            return node
    assert False

def find_node_properties(graph, idx):
    node = find_node(graph, idx)
    assert node != None
    ps = {}
    for p in node.find('properties'):
        ps[p.attrib['name']] = p.text.strip()
    return ps

def xml2graphs(xml_root, graph_filter, args):
    graphs = []
    graph_id = 0
    for group in xml_root:
        method = group.find('method')
        method_name = method.attrib['name']
        short_method_name = method.attrib['shortName'].strip()
        bci = int(method.attrib['bci'])
        for graph in group.findall('graph'):
            graph_name = graph.attrib['name']
            if not matches((graph_id, short_method_name, graph_name),
                           graph_filter):
                graph_id += 1
                continue
            # Load the entire graph first.
            G = nx.MultiDiGraph()
            G.graph['id'] = graph_id
            G.graph['method'] = short_method_name
            G.graph['phase'] = graph_name
            G.graph['context'] = {'args' : args}
            if not args.list:
                for node in graph.find('nodes'):
                    idx = int(node.attrib['id'])
                    properties = find_node_properties(graph, idx)
                    G.add_node(idx, **properties)
                for edge in graph.find('edges'):
                    src = int(edge.attrib['from'])
                    dst = int(edge.attrib['to'])
                    ind = int(edge.attrib['index'])
                    # The XML file sometimes contains (src,dst,ind) duplicates.
                    if not G.has_edge(src, dst, key=ind):
                        G.add_edge(src, dst, key=ind)
            # Load the control-flow graph, if available.
            CFG = None
            if graph.find('controlFlow'):
                CFG = nx.DiGraph()
                if not args.list:
                    for xmlblock in graph.find('controlFlow'):
                        block = int(xmlblock.attrib['name'])
                        # The node order reflects the local schedule.
                        nodes = []
                        for xmlnode in xmlblock.find('nodes'):
                            node = int(xmlnode.attrib['id'])
                            nodes.append(node)
                        CFG.add_node(block, **{'nodes' : nodes})
                        for xmlsucc in xmlblock.find('successors'):
                            succ = int(xmlsucc.attrib['name'])
                            CFG.add_edge(block, succ)
            G.graph['cfg'] = CFG
            graphs.append(G)
            graph_id += 1
    return graphs

filter_symbols = {'id' : 'id: int',
                  'method' : 'method: str',
                  'phase' : 'phase: str'}
def matches(graph_tuple, filter):
    (id, method, phase) = graph_tuple
    loc = locals()
    filter_locals = dict([(sym, loc[sym]) for sym in filter_symbols.keys()])
    return eval(filter, {}, filter_locals)

def add_feature_argument(parser, feature, help_msg, default):
    """
    Add a Boolean, mutually-exclusive feature argument to a parser.
    """
    if default:
        default_option = '--' + feature
    else:
        default_option = '--no-' + feature
    help_string = help_msg + " (default: " + default_option + ")"
    feature_parser = parser.add_mutually_exclusive_group(required=False)
    feature_lower = feature.replace('-', '_')
    feature_parser.add_argument('--' + feature,
                                dest=feature_lower,
                                action='store_true',
                                help=help_string)
    feature_parser.add_argument('--no-' + feature,
                                dest=feature_lower,
                                action='store_false',
                                help=argparse.SUPPRESS)
    parser.set_defaults(**{feature_lower:default})

def parse_graphs(xml_file, graph_filter, args):
    # Parse XML file.
    if args.verbose:
        print("parsing input file " + xml_file + " ...")
    tree = et.parse(xml_file)
    root = tree.getroot()

    # Convert XML to a map from id to ((method, phase), NetworkX graph,
    # maybe CFG) tuples.
    if args.verbose:
        print("converting XML to graphs ...")
    graphs = xml2graphs(root, graph_filter, args)

    # If asked for, list the graphs (id, method, phase).
    if args.verbose or args.list:
        table = [('id', 'method', 'phase')] + \
            [(G.graph['id'], G.graph['method'], G.graph['phase'])
             for G in graphs]
        ws = [max(map(len, map(str, c))) for c in zip(*table)]
        for r in table:
            print('  '.join((str(v).ljust(w) for v, w in zip(r, ws))))
    # If asked explicitly or the list is empty, terminate at this point.
    if args.list or not graphs:
        return None

    # Complete the basic attributes in the parsed graphs.
    for G in graphs:
        # Add id as an attribute (can be decoupled e.g. after inlining).
        for node in G.nodes:
            G.nodes[node]['id'] = node
        # Add category attribute to each edge. This needs to be kept for
        # each edge, as it might otherwise get lost when e.g. folding projs.
        for (src, dst, ind) in G.edges:
            G.edges[src, dst, ind]['category'] = G.nodes[src]['category']

    return graphs

def main():
    parser = argparse.ArgumentParser(
        description="Diffs two graphs in XML graph files.",
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
        usage='%(prog)s XML_FILE1 FILTER1 XML_FILE2 FILTER2')

    parser.add_argument('XML_FILE1',
                        help="XML graph file emitted by the HotSpot JVM")
    parser.add_argument('FILTER1',
                        default='True',
                        help=
"""predicate telling which graph to use in the comparison (default: %(default)s)
-- arbitrary Python expression on the following graph properties:
""" + '\n'.join(filter_symbols.values()) +
"""
(if many graphs are selected, the first one is used)
"""
    )
    parser.add_argument('XML_FILE2')
    parser.add_argument('FILTER2')
    add_feature_argument(parser,
                         'verbose',
                         "print debug information to the standard output",
                         False)
    add_feature_argument(parser,
                         'list',
                         "list properties of each graph and terminate",
                         False)
    parser.add_argument('--help',
                        action='help',
                        default=argparse.SUPPRESS,
                        help='Show this help message and exit')

    args = parser.parse_args()

    graphs1 = parse_graphs(args.XML_FILE1, args.FILTER1, args)
    graphs2 = parse_graphs(args.XML_FILE2, args.FILTER2, args)
    if graphs1 == None or graphs2 == None:
        return
    G1 = graphs1[0]
    G2 = graphs2[0]

    if args.verbose:
        print("comparing " + str((G1.graph['id'], G1.graph['method'], str(G1.graph['phase']))) + ' in ' + args.XML_FILE1 + " with node list:\n" + str(sorted(G1.nodes())))
        print("     with " + str((G2.graph['id'], G2.graph['method'], str(G2.graph['phase']))) + ' in ' + args.XML_FILE2 + " with node list:\n" + str(sorted(G2.nodes())))
    bestcost = None
    for node_path, edge_path, cost in \
        nx.optimize_edit_paths(G1, G2, strictly_decreasing=True):
        print('cost: ' + str(cost))
        for (before, after) in node_path:
            if before != after:
                if before == None:
                    print("insert " + str(after))
                elif after == None:
                    print("delete " + str(before))
                else:
                    print("replace " + str(before) + " with " + str(after))

if __name__ == '__main__':
    main()
